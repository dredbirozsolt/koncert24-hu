const express = require('express');
const router = express.Router();
const { CronJob } = require('../models');
const { requireAdmin } = require('../middleware/auth');
const cronService = require('../services/cronService');
const logger = require('../config/logger');

/**
 * GET /admin/cron
 * Cron Jobs kezelő oldal
 */
router.get('/', requireAdmin, (req, res) => {
  try {
    res.render('admin/cron-jobs', {
      layout: 'layouts/admin',
      title: 'Ütemezett Feladatok',
      currentPath: req.path,
      csrfToken: res.locals.csrfToken || req.session?.csrfToken || '',
      messages: req.session.messages || {}
    });

    // Clear messages after rendering
    req.session.messages = {};
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      path: req.path
    }, 'Error loading cron jobs page');

    res.status(500).render('error', {
      message: 'Hiba az ütemezett feladatok oldal betöltése során',
      error: process.env.NODE_ENV === 'development' ? error : {}
    });
  }
});
// Segédfüggvények a következő futás kiszámításához

// ============================================
// PATTERN MATCHER FUNCTIONS (complexity reduction)
// ============================================

function matchMinuteLevel(parts, now) {
  const { minute, hour, dayOfMonth, month, dayOfWeek } = parts;
  const allWildcards = hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*';
  if (!allWildcards) { return null; }

  if (minute.startsWith('*/')) {
    return getNextEveryXMinutes(now, parseInt(minute.substring(2), 10));
  }
  if (/^\d+$/.test(minute)) {
    return getNextHourlyAtMinute(now, parseInt(minute, 10));
  }
  const minuteRangeMatch = minute.match(/^(\d+)-(\d+)$/);
  if (minuteRangeMatch) {
    return getNextMinuteRangeInHour(now, parseInt(minuteRangeMatch[1], 10), parseInt(minuteRangeMatch[2], 10));
  }
  if (minute.includes(',')) {
    return getNextAtMinutes(now, minute.split(',').map((m) => parseInt(m.trim(), 10)));
  }
  return null;
}

function matchHourLevel(parts, now) {
  const { minute, hour, dayOfMonth, month, dayOfWeek } = parts;
  const dailyWildcards = dayOfMonth === '*' && month === '*' && dayOfWeek === '*';
  if (!dailyWildcards) { return null; }

  if (hour.startsWith('*/')) {
    const targetMinute = minute === '*' ? 0 : parseInt(minute, 10);
    return getNextEveryXHours(now, parseInt(hour.substring(2), 10), targetMinute);
  }
  const hourRangeMatch = hour.match(/^(\d+)-(\d+)$/);
  if (hourRangeMatch && /^\d+$/.test(minute)) {
    return getNextHourRangeAtMinute(
      now, parseInt(hourRangeMatch[1], 10), parseInt(hourRangeMatch[2], 10), parseInt(minute, 10)
    );
  }
  if (hour.includes(',') && /^\d+$/.test(minute)) {
    return getNextAtHours(
      now, hour.split(',').map((h) => parseInt(h.trim(), 10)), parseInt(minute, 10)
    );
  }
  return null;
}

function matchDailyLevel(parts, now) {
  const { minute, hour, dayOfMonth, month, dayOfWeek } = parts;
  if (/^\d+$/.test(minute) && /^\d+$/.test(hour) && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
    return getNextDailyAtTime(now, parseInt(hour, 10), parseInt(minute, 10));
  }
  return null;
}

function matchWeeklyLevel(parts, now) {
  const { minute, hour, dayOfMonth, month, dayOfWeek } = parts;
  const monthlyWildcards = dayOfMonth === '*' && month === '*';
  if (!monthlyWildcards || !(/^\d+$/.test(minute) && /^\d+$/.test(hour))) { return null; }

  if (/^\d+$/.test(dayOfWeek)) {
    return getNextWeeklyAtDayAndTime(now, parseInt(dayOfWeek, 10), parseInt(hour, 10), parseInt(minute, 10));
  }
  if (dayOfWeek.includes(',')) {
    return getNextOnWeekdays(
      now, dayOfWeek.split(',').map((d) => parseInt(d.trim(), 10)),
      parseInt(hour, 10), parseInt(minute, 10)
    );
  }
  const dowRangeMatch = dayOfWeek.match(/^(\d+)-(\d+)$/);
  if (dowRangeMatch) {
    return getNextWeekdayRange(
      now, parseInt(dowRangeMatch[1], 10), parseInt(dowRangeMatch[2], 10),
      parseInt(hour, 10), parseInt(minute, 10)
    );
  }
  return null;
}

function matchMonthlyLevel(parts, now) {
  const { minute, hour, dayOfMonth, month, dayOfWeek } = parts;
  const yearlyWildcards = month === '*' && dayOfWeek === '*';
  if (!yearlyWildcards || !(/^\d+$/.test(minute) && /^\d+$/.test(hour))) { return null; }

  if (/^\d+$/.test(dayOfMonth)) {
    return getNextMonthlyAtDayAndTime(now, parseInt(dayOfMonth, 10), parseInt(hour, 10), parseInt(minute, 10));
  }
  const dayRangeMatch = dayOfMonth.match(/^(\d+)-(\d+)$/);
  if (dayRangeMatch) {
    const rangeStart = parseInt(dayRangeMatch[1], 10);
    const rangeEnd = parseInt(dayRangeMatch[2], 10);
    if (rangeStart === 1 && rangeEnd === 7 && /^\d+$/.test(dayOfWeek)) {
      return getNextFirstWeekdayOfMonth(now, parseInt(dayOfWeek, 10), parseInt(hour, 10), parseInt(minute, 10));
    }
    return getNextDayRangeAtTime(now, rangeStart, rangeEnd, parseInt(hour, 10), parseInt(minute, 10));
  }
  if (dayOfMonth.includes(',')) {
    return getNextOnMonthDays(
      now, dayOfMonth.split(',').map((d) => parseInt(d.trim(), 10)),
      parseInt(hour, 10), parseInt(minute, 10)
    );
  }
  if (month.startsWith('*/') && /^\d+$/.test(dayOfMonth)) {
    return getNextEveryXMonths(
      now, parseInt(month.substring(2), 10), parseInt(dayOfMonth, 10),
      parseInt(hour, 10), parseInt(minute, 10)
    );
  }
  return null;
}

function matchYearlyLevel(parts, now) {
  const { minute, hour, dayOfMonth, month, dayOfWeek } = parts;
  if (dayOfWeek !== '*' || !(/^\d+$/.test(minute) && /^\d+$/.test(hour) && /^\d+$/.test(dayOfMonth))) { return null; }

  if (/^\d+$/.test(month)) {
    return getNextYearlyAtDate(
      now, parseInt(month, 10), parseInt(dayOfMonth, 10),
      parseInt(hour, 10), parseInt(minute, 10)
    );
  }
  if (month.includes(',')) {
    return getNextOnMonths(
      now, month.split(',').map((m) => parseInt(m.trim(), 10)),
      parseInt(dayOfMonth, 10), parseInt(hour, 10), parseInt(minute, 10)
    );
  }
  const monthRangeMatch = month.match(/^(\d+)-(\d+)$/);
  if (monthRangeMatch) {
    return getNextMonthRange({
      now,
      monthStart: parseInt(monthRangeMatch[1], 10),
      monthEnd: parseInt(monthRangeMatch[2], 10),
      day: parseInt(dayOfMonth, 10),
      hour: parseInt(hour, 10),
      minute: parseInt(minute, 10)
    });
  }
  return null;
}

function matchSpecialLevel(schedule, now) {
  if (schedule === '0 3 * * 0#1' || /^\d+ \d+ \* \* \d+#1$/.test(schedule)) {
    const parts = schedule.match(/^(\d+) (\d+) \* \* (\d+)#1$/);
    if (parts) {
      return getNextFirstWeekdayOfMonth(now, parseInt(parts[3], 10), parseInt(parts[2], 10), parseInt(parts[1], 10));
    }
  }
  return null;
}
function getNextCronTime(schedule) {
  try {
    const now = new Date();
    const [minute, hour, dayOfMonth, month, dayOfWeek] = schedule.split(' ');
    const parts = { minute, hour, dayOfMonth, month, dayOfWeek };
    return matchMinuteLevel(parts, now)
      || matchHourLevel(parts, now)
      || matchDailyLevel(parts, now)
      || matchWeeklyLevel(parts, now)
      || matchMonthlyLevel(parts, now)
      || matchYearlyLevel(parts, now)
      || matchSpecialLevel(schedule, now)
      || getNextDay(now);
  } catch (error) {
    logger.error({ err: error, schedule }, 'Cron parse error');
    return null;
  }
}
// Perces intervallumok: */X * * * *
function getNextEveryXMinutes(now, interval) {
  const next = new Date(now);
  const currentMinute = next.getMinutes();
  const currentSecond = next.getSeconds();
  const nextMinute = Math.ceil((currentMinute + (currentSecond > 0 ? 1 : 0)) / interval) * interval;

  next.setMinutes(nextMinute, 0, 0);
  if (next <= now) {
    next.setMinutes(next.getMinutes() + interval);
  }
  return next.toISOString();
}
// Konkrét perc minden órában: X * * * *
function getNextHourlyAtMinute(now, minute) {
  const next = new Date(now);
  next.setMinutes(minute, 0, 0);
  if (next <= now) {
    next.setHours(next.getHours() + 1);
  }
  return next.toISOString();
}

// Óránkénti intervallumok: X */Y * * *
function getNextEveryXHours(now, interval, minute = 0) {
  const next = new Date(now);
  const currentHour = next.getHours();
  const currentMinute = next.getMinutes();

  // Dinamikus intervallum slotok generálása (pl. interval=6 -> [0, 6, 12, 18])
  const slots = [];
  for (let h = 0; h < 24; h += interval) {
    slots.push(h);
  }

  // Keressük a következő slotot
  let nextSlot = slots.find((slot) => {
    if (slot > currentHour) {return true;}
    return slot === currentHour && currentMinute < minute;
  });

  // Ha nincs több slot ma, akkor holnap az első slot
  if (!nextSlot && nextSlot !== 0) {
    next.setDate(next.getDate() + 1);
    nextSlot = slots[0];
  }

  next.setHours(nextSlot, minute, 0, 0);
  return next.toISOString();
}

// Napi időpont: X Y * * *
function getNextDailyAtTime(now, hour, minute = 0) {
  const next = new Date(now);
  next.setHours(hour, minute, 0, 0);
  if (next <= now) {
    next.setDate(next.getDate() + 1);
  }
  return next.toISOString();
}

// Havi konkrét nap: X Y Z * *
function getNextMonthlyAtDayAndTime(now, day, hour, minute) {
  const next = new Date(now);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);

  // Ha a dátum már elmúlt ebben a hónapban, menjünk a következő hónapra
  if (next <= now) {
    next.setMonth(next.getMonth() + 1);
    next.setDate(day);
  }

  return next.toISOString();
}

// Nap-tartomány: X Y A-B * * (pl. 0 5 1-7 * *)
function getNextDayRangeAtTime(now, rangeStart, rangeEnd, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDate();

  // Keressük a következő napot a tartományban
  for (let day = currentDay; day <= rangeEnd; day++) {
    next.setDate(day);
    next.setHours(hour, minute, 0, 0);

    if (next > now && day >= rangeStart && day <= rangeEnd) {
      return next.toISOString();
    }
  }

  // Ha ebben a hónapban már nincs, akkor következő hónap első napja a tartományból
  next.setMonth(next.getMonth() + 1);
  next.setDate(rangeStart);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Heti konkrét nap: X Y * * Z
function getNextWeeklyAtDayAndTime(now, dayOfWeek, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDay();

  // Számoljuk ki, hány nap múlva van a cél nap
  let daysUntil = dayOfWeek - currentDay;
  if (daysUntil < 0) {
    daysUntil += 7;
  } else if (daysUntil === 0) {
    // Ma van a cél nap - nézzük meg az időt
    next.setHours(hour, minute, 0, 0);
    if (next <= now) {
      daysUntil = 7; // Következő héten
    }
  }

  next.setDate(next.getDate() + daysUntil);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Éves konkrét dátum: X Y Z W *
function getNextYearlyAtDate(now, month, day, hour, minute) {
  const next = new Date(now);
  next.setMonth(month - 1); // JavaScript hónapok 0-indexeltek
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);

  // Ha már elmúlt idén, akkor jövőre
  if (next <= now) {
    next.setFullYear(next.getFullYear() + 1);
  }

  return next.toISOString();
}

function getNextDay(now) {
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  return tomorrow.toISOString();
}

// ============================================
// KIEGÉSZÍTŐ SEGÉDFÜGGVÉNYEK (új minták)
// ============================================

// Perc-tartomány: X-Y * * * *
function getNextMinuteRangeInHour(now, rangeStart, rangeEnd) {
  const next = new Date(now);
  const currentMinute = next.getMinutes();

  // Keressük a következő percet a tartományban
  for (let min = currentMinute + 1; min <= rangeEnd; min++) {
    if (min >= rangeStart) {
      next.setMinutes(min, 0, 0);
      return next.toISOString();
    }
  }

  // Következő óra első perce a tartományból
  next.setHours(next.getHours() + 1);
  next.setMinutes(rangeStart, 0, 0);
  return next.toISOString();
}

// Több konkrét perc: X,Y,Z * * * *
function getNextAtMinutes(now, minutes) {
  const next = new Date(now);
  const currentMinute = next.getMinutes();

  const sortedMinutes = minutes.sort((a, b) => a - b);
  const nextMinute = sortedMinutes.find((m) => m > currentMinute);

  if (nextMinute === undefined) {
    next.setHours(next.getHours() + 1);
    next.setMinutes(sortedMinutes[0], 0, 0);
  } else {
    next.setMinutes(nextMinute, 0, 0);
  }

  return next.toISOString();
}

// Óra-tartomány: X Y-Z * * *
function getNextHourRangeAtMinute(now, rangeStart, rangeEnd, minute) {
  const next = new Date(now);
  const currentHour = next.getHours();

  // Keressük a következő órát a tartományban
  for (let hour = currentHour; hour <= rangeEnd; hour++) {
    if (hour >= rangeStart) {
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő nap első órája a tartományból
  next.setDate(next.getDate() + 1);
  next.setHours(rangeStart, minute, 0, 0);
  return next.toISOString();
}

// Több konkrét óra: X Y,Z * * *
function getNextAtHours(now, hours, minute) {
  const next = new Date(now);
  const currentHour = next.getHours();
  const currentMinute = next.getMinutes();

  const sortedHours = hours.sort((a, b) => a - b);
  const nextHour = sortedHours.find((h) => h > currentHour || (h === currentHour && minute > currentMinute));

  if (nextHour === undefined) {
    next.setDate(next.getDate() + 1);
    next.setHours(sortedHours[0], minute, 0, 0);
  } else {
    next.setHours(nextHour, minute, 0, 0);
  }

  return next.toISOString();
}

// Több hétköznap: X Y * * A,B,C
function getNextOnWeekdays(now, daysOfWeek, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDay();

  const sortedDays = daysOfWeek.sort((a, b) => a - b);

  // Próbáljuk meg ma
  next.setHours(hour, minute, 0, 0);
  if (next > now && sortedDays.includes(currentDay)) {
    return next.toISOString();
  }

  // Keressük a következő napot
  for (let i = 1; i <= 7; i++) {
    const testDay = (currentDay + i) % 7;
    if (sortedDays.includes(testDay)) {
      next.setDate(next.getDate() + i);
      next.setHours(hour, minute, 0, 0);
      return next.toISOString();
    }
  }

  return next.toISOString();
}

// Hétköznap-tartomány: X Y * * A-B
function getNextWeekdayRange(now, dowStart, dowEnd, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDay();

  // Próbáljuk meg ma
  next.setHours(hour, minute, 0, 0);
  if (next > now && currentDay >= dowStart && currentDay <= dowEnd) {
    return next.toISOString();
  }

  // Keressük a következő napot a tartományban
  for (let i = 1; i <= 7; i++) {
    const testDay = (currentDay + i) % 7;
    if (testDay >= dowStart && testDay <= dowEnd) {
      next.setDate(next.getDate() + i);
      next.setHours(hour, minute, 0, 0);
      return next.toISOString();
    }
  }

  return next.toISOString();
}

// Több konkrét nap havonta: X Y A,B,C * *
function getNextOnMonthDays(now, days, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDate();

  const sortedDays = days.sort((a, b) => a - b);

  // Próbáljuk meg ebben a hónapban
  for (const day of sortedDays) {
    if (day > currentDay || (day === currentDay && next.getHours() < hour)
        || (day === currentDay && next.getHours() === hour && next.getMinutes() < minute)) {
      next.setDate(day);
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő hónap első napja a listából
  next.setMonth(next.getMonth() + 1);
  next.setDate(sortedDays[0]);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Első adott hétköznap a hónapban: X Y 1-7 * Z vagy X Y * * Z#1
function getNextFirstWeekdayOfMonth(now, dayOfWeek, hour, minute) {
  // Aktuális hónap első adott hétköznapja
  const currentMonthFirst = new Date(now.getFullYear(), now.getMonth(), 1);
  const firstTarget = new Date(currentMonthFirst);

  while (firstTarget.getDay() !== dayOfWeek) {
    firstTarget.setDate(firstTarget.getDate() + 1);
  }
  firstTarget.setHours(hour, minute, 0, 0);

  if (now < firstTarget) {
    return firstTarget.toISOString();
  }

  // Következő hónap első adott hétköznapja
  const nextMonthFirst = new Date(now.getFullYear(), now.getMonth() + 1, 1);
  const nextFirstTarget = new Date(nextMonthFirst);

  while (nextFirstTarget.getDay() !== dayOfWeek) {
    nextFirstTarget.setDate(nextFirstTarget.getDate() + 1);
  }
  nextFirstTarget.setHours(hour, minute, 0, 0);
  return nextFirstTarget.toISOString();
}

// Hónap intervallum: X Y Z */N *
function getNextEveryXMonths(now, interval, day, hour, minute) {
  const next = new Date(now);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);

  // Ha már elmúlt ebben a hónapban
  if (next <= now) {
    next.setMonth(next.getMonth() + interval);
    next.setDate(day);
  }

  return next.toISOString();
}

// Több hónap: X Y Z W,X *
function getNextOnMonths(now, months, day, hour, minute) {
  const next = new Date(now);
  const currentMonth = next.getMonth() + 1; // 1-12

  const sortedMonths = months.sort((a, b) => a - b);

  // Próbáljuk meg idén
  for (const month of sortedMonths) {
    const isMonthPassed = month > currentMonth
        || (month === currentMonth && next.getDate() < day)
        || (month === currentMonth && next.getDate() === day && next.getHours() < hour)
        || (month === currentMonth && next.getDate() === day && next.getHours() === hour
          && next.getMinutes() < minute);
    if (isMonthPassed) {
      next.setMonth(month - 1);
      next.setDate(day);
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő évben az első hónap
  next.setFullYear(next.getFullYear() + 1);
  next.setMonth(sortedMonths[0] - 1);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Hónap-tartomány: X Y Z W-Y *
function getNextMonthRange({ now, monthStart, monthEnd, day, hour, minute }) {
  const next = new Date(now);
  const currentMonth = next.getMonth() + 1;

  // Próbáljuk meg ebben az évben
  for (let month = currentMonth; month <= monthEnd; month++) {
    if (month >= monthStart) {
      next.setMonth(month - 1);
      next.setDate(day);
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő évben az első hónap a tartományból
  next.setFullYear(next.getFullYear() + 1);
  next.setMonth(monthStart - 1);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// ============================================
// RÉGI FÜGGVÉNYEK (backwards compatibility - már nem használt, de meghagyva)
// ============================================

// Cron státusz lekérdezése
router.get('/status', requireAdmin, async (req, res) => {
  try {
    const jobs = await CronJob.findAll();
    const cronJobs = jobs.map((job) => {
      const nextIso = getNextCronTime(job.schedule);
      let nextRun = null;
      if (nextIso) {
        const d = new Date(nextIso);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hour = String(d.getHours()).padStart(2, '0');
        const minute = String(d.getMinutes()).padStart(2, '0');
        nextRun = `${year}. ${month}. ${day}. ${hour}:${minute}`;
      }
      return {
        id: job.id,
        name: job.name,
        description: job.description,
        schedule: job.schedule,
        isActive: job.isActive,
        lastRun: null, // TODO: implement tracking
        nextRun
      };
    });
    res.json({ success: true, cronJobs });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Cron frissítése
router.post('/update', requireAdmin, async (req, res) => {
  try {
    const { id, schedule, isActive } = req.body;
    if (!id || !schedule) {
      return res.status(400).json({ success: false, message: 'Hiányzó adat.' });
    }
    const job = await CronJob.findByPk(id);
    if (!job) {
      return res.status(404).json({ success: false, message: 'Feladat nem található.' });
    }
    job.schedule = schedule;
    if (typeof isActive !== 'undefined') { job.isActive = Boolean(isActive); }
    await job.save();

    // Reload cron jobs to apply changes immediately
    const reloadResult = await cronService.reloadCronJobs();

    if (!reloadResult.success) {
      logger.warn({
        service: 'adminCron',
        operation: 'updateCronJob',
        jobId: id,
        reloadError: reloadResult.message
      }, 'Cron job updated but reload failed');
      return res.json({
        success: true,
        message: 'Feladat mentve, de az újratöltés sikertelen volt. Indítsd újra a szervert.'
      });
    }

    res.json({ success: true, message: 'Feladat frissítve és újratöltve.' });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Cron jobs újratöltése (hot reload)
router.post('/reload', requireAdmin, async (req, res) => {
  try {
    const result = await cronService.reloadCronJobs();
    res.json(result);
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Aktív cron job-ok listája
router.get('/active', requireAdmin, (req, res) => {
  try {
    const activeTasks = cronService.getActiveCronTasks();
    res.json({ success: true, activeTasks });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// ============================================
// MANUÁLIS FUTTATÁSI ENDPOINTOK
// ============================================

/**
 * POST /admin/cron/sync/performers
 * Manuális előadó szinkronizálás vTiger-ből
 */
router.post('/sync/performers', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualSync',
      type: 'performers',
      userId: req.session?.userId
    }, 'Manual performer sync triggered');

    const { SyncService } = require('../services/syncService');
    const syncService = new SyncService();
    const result = await syncService.syncPerformers(false);

    if (result.success) {
      await updateCronJobLastRun('performer-sync');
      res.json({
        success: true,
        message: 'Előadó szinkronizálás sikeresen lefutott!'
      });
    } else {
      res.status(500).json({
        success: false,
        message: `Előadó szinkronizálás sikertelen: ${result.error}`
      });
    }
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId
    }, 'Performer sync error');

    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/sync/geonames
 * Manuális GeoNames hely szinkronizálás
 */
router.post('/sync/geonames', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualSync',
      type: 'geonames',
      userId: req.session?.userId
    }, 'Manual GeoNames sync triggered');

    const GeoNamesLocationCronService = require('../services/geoNamesLocationCronService');
    await GeoNamesLocationCronService.performMonthlySync();

    await updateCronJobLastRun('geonames-sync');
    res.json({
      success: true,
      message: 'GeoNames szinkronizálás sikeresen lefutott!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      syncType: 'geonames'
    }, 'GeoNames sync error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/sync/bookings
 * Manuális foglalás szinkronizálás vTiger-be
 */
router.post('/sync/bookings', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualSync',
      type: 'bookings',
      userId: req.session?.userId
    }, 'Manual booking sync triggered');

    await cronService.syncBookingsToVTiger();

    await updateCronJobLastRun('booking-sync');
    res.json({
      success: true,
      message: 'Foglalás szinkronizálás sikeresen lefutott!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      syncType: 'bookings'
    }, 'Booking sync error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/sync/events
 * Manuális esemény szinkronizálás vTiger Sales Orders-ből
 */
router.post('/sync/events', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualSync',
      type: 'events',
      userId: req.session?.userId
    }, 'Manual event sync triggered');

    const eventCronService = require('../services/eventCronService');
    const result = await eventCronService.runEventSync();

    await updateCronJobLastRun('event-sync');

    // Result tartalmazza a stats objektumot (processed, created, updated, stb.)
    const summary = `Feldolgozva: ${result.processed}, Létrehozva: ${result.created}, `
      + `Frissítve: ${result.updated}`;

    res.json({
      success: true,
      message: `Esemény szinkronizálás befejezve! (${summary})`
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      syncType: 'events'
    }, 'Event sync error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/maintenance
 * Manuális napi karbantartás futtatás
 */
router.post('/run/maintenance', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'maintenance',
      userId: req.session?.userId
    }, 'Manual maintenance triggered');

    await cronService.performDailyMaintenance();

    await updateCronJobLastRun('daily-maintenance');
    res.json({
      success: true,
      message: 'Napi karbantartás sikeresen lefutott!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'maintenance'
    }, 'Daily maintenance error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/backup
 * Manuális backup futtatás
 */
router.post('/run/backup', requireAdmin, async (req, res) => {
  try {
    const path = require('path');
    const fs = require('fs').promises;
    const { exec } = require('child_process');
    const util = require('util');
    const execPromise = util.promisify(exec);

    logger.info({
      service: 'adminCron',
      operation: 'manualBackup',
      userId: req.user?.id
    }, 'Manual backup triggered by admin');

    const backupScript = path.join(process.cwd(), 'backup.sh');

    // Check if script exists
    try {
      await fs.access(backupScript, fs.constants.R_OK);
    } catch {
      return res.status(404).json({
        success: false,
        message: 'backup.sh script nem található vagy nem olvasható.'
      });
    }

    // Execute backup
    const { stdout, stderr } = await execPromise(`bash "${backupScript}"`, {
      cwd: process.cwd(),
      maxBuffer: 10 * 1024 * 1024,
      timeout: 600000 // 10 minutes
    });

    if (stdout) {
      logger.info({
        service: 'adminCron',
        operation: 'backupOutput',
        outputLength: stdout.length
      }, 'Backup stdout:', stdout.substring(0, 500));
    }
    if (stderr) {
      logger.warn('Backup stderr:', stderr.substring(0, 500));
    }

    await updateCronJobLastRun('daily-backup');
    res.json({
      success: true,
      message: 'Backup sikeresen lefutott!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'backup'
    }, 'Backup error');
    res.status(500).json({
      success: false,
      message: `Backup hiba: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/chat-cleanup
 * Manuális chat session cleanup futtatás
 */
router.post('/run/chat-cleanup', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'chatCleanup',
      userId: req.session?.userId
    }, 'Manual chat cleanup triggered');

    const chatSessionCleanupService = require('../services/chatSessionCleanupService');
    const result = await chatSessionCleanupService.cleanupOldSessions();

    // Update job status: lastRun + clear error
    await CronJob.update(
      { lastRun: new Date(), lastError: null, lastStatus: 'success' },
      { where: { id: 'chat-session-cleanup' } }
    );

    res.json({
      success: true,
      message: `Chat cleanup sikeres! ${result.softDeleted} session törölve és anonimizálva.`,
      result
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'chatCleanup'
    }, 'Chat cleanup error');

    // Update job status: error
    await CronJob.update(
      { lastRun: new Date(), lastError: error.message, lastStatus: 'error' },
      { where: { id: 'chat-session-cleanup' } }
    );

    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/blog-publish
 * Manuális scheduled blog publish futtatás
 */
router.post('/run/blog-publish', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'blogPublish',
      userId: req.session?.userId
    }, 'Manual blog publish triggered');

    const { BlogPost } = require('../models');
    const published = await BlogPost.publishScheduledPosts();

    await updateCronJobLastRun('blog-scheduled-publish');
    res.json({
      success: true,
      message: `Ütemezett blog posztok publikálása sikeres! ${published.length} poszt publikálva.`,
      published: published.length
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'blogPublish'
    }, 'Blog publish error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/admin-heartbeat
 * Manuális admin heartbeat cleanup futtatás
 */
router.post('/run/admin-heartbeat', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'adminHeartbeat',
      userId: req.session?.userId
    }, 'Manual admin heartbeat cleanup triggered');

    const availabilityService = require('../services/availabilityService');
    await availabilityService.cleanupStaleAdmins();

    await updateCronJobLastRun('admin-heartbeat-cleanup');
    res.json({
      success: true,
      message: 'Admin heartbeat cleanup sikeres!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'adminHeartbeat'
    }, 'Admin heartbeat cleanup error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/security-alert-check
 * Manuális security alert check futtatás
 */
router.post('/run/security-alert-check', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'securityAlertCheck',
      userId: req.session?.userId
    }, 'Manual security alert check triggered');

    const securityAlertService = require('../services/securityAlertService');
    await securityAlertService.checkAndAlert();

    await updateCronJobLastRun('security-alert-check');
    res.json({
      success: true,
      message: 'Biztonsági riasztások ellenőrzése sikeres!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'securityAlertCheck'
    }, 'Security alert check error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/security-log-cleanup
 * Manuális security log cleanup futtatás
 */
router.post('/run/security-log-cleanup', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'securityLogCleanup',
      userId: req.session?.userId
    }, 'Manual security log cleanup triggered');

    await cronService.cleanupOldSecurityLogs();

    await updateCronJobLastRun('security-log-cleanup');
    res.json({
      success: true,
      message: 'Biztonsági logok törlése sikeres!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'securityLogCleanup'
    }, 'Security log cleanup error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/geonames-stats
 * Manuális GeoNames statistics generation futtatás
 */
router.post('/run/geonames-stats', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'geonamesStats',
      userId: req.session?.userId
    }, 'Manual GeoNames stats generation triggered');

    const geoNamesLocationCronService = require('../services/geoNamesLocationCronService');
    await geoNamesLocationCronService.generateMonthlyStats();

    await updateCronJobLastRun('geonames-stats');
    res.json({
      success: true,
      message: 'GeoNames statisztikák generálása sikeres!'
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'geonamesStats'
    }, 'GeoNames stats generation error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/infrastructure-health
 * Manuális infrastructure health check futtatás
 */
router.post('/run/infrastructure-health', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'infrastructureHealth',
      userId: req.session?.userId
    }, 'Manual infrastructure health check triggered');

    const infrastructureAlertService = require('../services/infrastructureAlertService');
    const results = await infrastructureAlertService.runHealthChecks();

    await updateCronJobLastRun('infrastructure-health-check');

    const status = results.database.healthy && results.diskSpace.healthy ? 'Minden rendben!' : 'Problémák észlelve!';
    const diskSpaceStatus = results.diskSpace.healthy ? '✅ OK' : `⚠️ ${results.diskSpace.usage}%`;
    const details = [
      `Database: ${results.database.healthy ? '✅ OK' : '❌ HIBA'}`,
      `Disk Space: ${diskSpaceStatus}`
    ];

    res.json({
      success: true,
      message: `Infrastructure ellenőrzés befejezve! ${status}`,
      details: details.join(', '),
      results
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'infrastructureHealth'
    }, 'Infrastructure health check error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * POST /admin/cron/run/offline-email-retry
 * Manuális offline message email újraküldés
 */
router.post('/run/offline-email-retry', requireAdmin, async (req, res) => {
  try {
    logger.info({
      service: 'adminCron',
      operation: 'manualRun',
      type: 'offlineEmailRetry',
      userId: req.session?.userId
    }, 'Manual offline email retry triggered');

    const { OfflineMessage } = require('../models');
    const chatService = require('../services/chatService');

    // Get unsent messages
    const unsentMessages = await OfflineMessage.getUnsentMessages();

    if (unsentMessages.length === 0) {
      return res.json({
        success: true,
        message: 'Nincs elküldetlen offline üzenet.',
        details: 'Minden email sikeresen el lett küldve.'
      });
    }

    let successCount = 0;
    let failCount = 0;

    for (const message of unsentMessages) {
      try {
        await chatService.sendOfflineMessageEmail(message);
        await message.markEmailSent();
        successCount += 1;
      } catch (error) {
        failCount += 1;
        logger.error({
          err: error,
          messageId: message.id
        }, 'Failed to retry offline message email');
      }
    }

    await updateCronJobLastRun('offline-message-email-retry');

    res.json({
      success: true,
      message: 'Email újraküldés befejezve!',
      details: `Sikeres: ${successCount}, Sikertelen: ${failCount}, Összesen: ${unsentMessages.length}`,
      successCount,
      failCount,
      total: unsentMessages.length
    });
  } catch (error) {
    logger.error({
      err: error,
      userId: req.session?.userId,
      jobType: 'offlineEmailRetry'
    }, 'Offline email retry error');
    res.status(500).json({
      success: false,
      message: `Hiba történt: ${error.message}`
    });
  }
});

/**
 * Helper: Update cron job lastRun timestamp
 * @param {string} jobId - Cron job ID
 */
async function updateCronJobLastRun(jobId) {
  try {
    const job = await CronJob.findByPk(jobId);
    if (job) {
      job.lastRun = new Date();
      await job.save();
    }
  } catch (error) {
    logger.error(
      { err: error, service: 'adminCron', operation: 'updateLastRun', jobId },
      'Failed to update lastRun'
    );
  }
}

module.exports = router;
