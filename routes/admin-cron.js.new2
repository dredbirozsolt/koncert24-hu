const express = require('express');
const router = express.Router();
const { CronJob } = require('../models');
const { requireAuth } = require('../middleware/auth');

/**
 * GET /admin/cron
 * Cron Jobs kezelő oldal
 */
router.get('/', requireAuth, (req, res) => {
  try {
    res.render('admin/cron-jobs', {
      title: 'Ütemezett Feladatok',
      siteName: process.env.SITE_NAME || 'koncert24.hu'
    });
  } catch (error) {
    console.error('Error loading cron jobs page:', error);
    res.status(500).render('error', {
      message: 'Hiba az ütemezett feladatok oldal betöltése során',
      error: process.env.NODE_ENV === 'development' ? error : {}
    });
  }
});
// Segédfüggvények a következő futás kiszámításához

function getNextCronTime(schedule) {
  try {
    const now = new Date();
    const [minute, hour, dayOfMonth, month, dayOfWeek] = schedule.split(' ');

    // ========== PERCES SZINTŰ ==========

    // 1a. Perces intervallumok: */X * * * *
    if (minute.startsWith('*/') && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const interval = parseInt(minute.substring(2), 10);
      return getNextEveryXMinutes(now, interval);
    }

    // 1b. Konkrét perc minden órában: X * * * *
    if (hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*' && /^\d+$/.test(minute)) {
      const targetMinute = parseInt(minute, 10);
      return getNextHourlyAtMinute(now, targetMinute);
    }

    // 1c. Perc-tartomány minden órában: X-Y * * * * (pl. 10-20 * * * *)
    const minuteRangeMatch = minute.match(/^(\d+)-(\d+)$/);
    if (minuteRangeMatch && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const rangeStart = parseInt(minuteRangeMatch[1], 10);
      const rangeEnd = parseInt(minuteRangeMatch[2], 10);
      return getNextMinuteRangeInHour(now, rangeStart, rangeEnd);
    }

    // 1d. Több konkrét perc: X,Y,Z * * * * (pl. 0,15,30,45 * * * *)
    if (minute.includes(',') && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const minutes = minute.split(',').map((m) => parseInt(m.trim(), 10));
      return getNextAtMinutes(now, minutes);
    }
    // ========== ÓRÁNKÉNTI SZINTŰ ==========
    // 2a. Óránkénti intervallumok: X */Y * * * (pl. 0 */6 * * *)
    if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const hourInterval = parseInt(hour.substring(2), 10);
      const targetMinute = minute === '*' ? 0 : parseInt(minute, 10);
      return getNextEveryXHours(now, hourInterval, targetMinute);
    }

    // 2b. Óra-tartomány: X Y-Z * * * (pl. 0 9-17 * * * = munkaórák)
    const hourRangeMatch = hour.match(/^(\d+)-(\d+)$/);
    if (hourRangeMatch && /^\d+$/.test(minute) && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const targetMinute = parseInt(minute, 10);
      const rangeStart = parseInt(hourRangeMatch[1], 10);
      const rangeEnd = parseInt(hourRangeMatch[2], 10);
      return getNextHourRangeAtMinute(now, rangeStart, rangeEnd, targetMinute);
    }

    // 2c. Több konkrét óra: X Y,Z * * * (pl. 0 6,12,18 * * *)
    if (hour.includes(',') && /^\d+$/.test(minute) && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const targetMinute = parseInt(minute, 10);
      const hours = hour.split(',').map((h) => parseInt(h.trim(), 10));
      return getNextAtHours(now, hours, targetMinute);
    }
    // ========== NAPI SZINTŰ ==========
    // 3a. Konkrét óra minden nap: X Y * * * (pl. 0 7 * * *)
    if (/^\d+$/.test(minute) && /^\d+$/.test(hour) && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      return getNextDailyAtTime(now, targetHour, targetMinute);
    }
    // ========== HETI SZINTŰ ==========
    // 4a. Heti ismétlődés konkrét napon: X Y * * Z (pl. 0 9 * * 1 = hétfő 9:00)
    if (/^\d+$/.test(minute) && /^\d+$/.test(hour) && dayOfMonth === '*' && month === '*' && /^\d+$/.test(dayOfWeek)) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDayOfWeek = parseInt(dayOfWeek, 10);
      return getNextWeeklyAtDayAndTime(now, targetDayOfWeek, targetHour, targetMinute);
    }

    // 4b. Több hétköznap: X Y * * A,B,C (pl. 0 8 * * 1,2,3,4,5 = munkanapokon)
    if (/^\d+$/.test(minute) && /^\d+$/.test(hour) && dayOfMonth === '*' && month === '*' && dayOfWeek.includes(',')) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const daysOfWeek = dayOfWeek.split(',').map((d) => parseInt(d.trim(), 10));
      return getNextOnWeekdays(now, daysOfWeek, targetHour, targetMinute);
    }

    // 4c. Hétköznap-tartomány: X Y * * A-B (pl. 0 8 * * 1-5 = hétfő-péntek)
    const dowRangeMatch = dayOfWeek.match(/^(\d+)-(\d+)$/);
    if (dowRangeMatch && /^\d+$/.test(minute) && /^\d+$/.test(hour) && dayOfMonth === '*' && month === '*') {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const dowStart = parseInt(dowRangeMatch[1], 10);
      const dowEnd = parseInt(dowRangeMatch[2], 10);
      return getNextWeekdayRange(now, dowStart, dowEnd, targetHour, targetMinute);
    }
    // ========== HAVI SZINTŰ ==========
    // 5a. Konkrét nap havonta: X Y Z * * (pl. 0 3 15 * *)
    if (/^\d+$/.test(minute) && /^\d+$/.test(hour) && /^\d+$/.test(dayOfMonth) && month === '*' && dayOfWeek === '*') {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDay = parseInt(dayOfMonth, 10);
      return getNextMonthlyAtDayAndTime(now, targetDay, targetHour, targetMinute);
    }

    // 5b. Nap-tartomány havonta: X Y A-B * * (pl. 0 5 1-7 * *)
    const dayRangeMatch = dayOfMonth.match(/^(\d+)-(\d+)$/);
    if (dayRangeMatch && /^\d+$/.test(minute) && /^\d+$/.test(hour) && month === '*' && dayOfWeek === '*') {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const rangeStart = parseInt(dayRangeMatch[1], 10);
      const rangeEnd = parseInt(dayRangeMatch[2], 10);
      return getNextDayRangeAtTime(now, rangeStart, rangeEnd, targetHour, targetMinute);
    }

    // 5c. Több konkrét nap havonta: X Y A,B,C * * (pl. 0 10 1,15 * *)
    if (dayOfMonth.includes(',') && /^\d+$/.test(minute) && /^\d+$/.test(hour) && month === '*' && dayOfWeek === '*') {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const days = dayOfMonth.split(',').map((d) => parseInt(d.trim(), 10));
      return getNextOnMonthDays(now, days, targetHour, targetMinute);
    }

    // 5d. Első/utolsó vasárnap: X Y 1-7 * 0 vagy X Y 1-7 * Z
    if (dayRangeMatch && dayRangeMatch[1] === '1' && dayRangeMatch[2] === '7' && /^\d+$/.test(dayOfWeek)) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDayOfWeek = parseInt(dayOfWeek, 10);
      return getNextFirstWeekdayOfMonth(now, targetDayOfWeek, targetHour, targetMinute);
    }

    // 5e. Hónap intervallum: X Y Z */N * (pl. 0 0 1 */3 * = negyedévente)
    const isMonthInterval = month.startsWith('*/') && /^\d+$/.test(minute) && /^\d+$/.test(hour)
      && /^\d+$/.test(dayOfMonth) && dayOfWeek === '*';
    if (isMonthInterval) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDay = parseInt(dayOfMonth, 10);
      const monthInterval = parseInt(month.substring(2), 10);
      return getNextEveryXMonths(now, monthInterval, targetDay, targetHour, targetMinute);
    }
    // ========== ÉVES SZINTŰ ==========
    // 6a. Konkrét dátum évente: X Y Z W * (pl. 0 0 1 1 * = január 1)
    const isYearlyExactDate = /^\d+$/.test(minute) && /^\d+$/.test(hour) && /^\d+$/.test(dayOfMonth)
      && /^\d+$/.test(month) && dayOfWeek === '*';
    if (isYearlyExactDate) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDay = parseInt(dayOfMonth, 10);
      const targetMonth = parseInt(month, 10);
      return getNextYearlyAtDate(now, targetMonth, targetDay, targetHour, targetMinute);
    }

    // 6b. Több hónap: X Y Z W,X * (pl. 0 0 1 1,7 * = jan 1 és júl 1)
    const isMonthList = month.includes(',') && /^\d+$/.test(minute) && /^\d+$/.test(hour)
      && /^\d+$/.test(dayOfMonth) && dayOfWeek === '*';
    if (isMonthList) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDay = parseInt(dayOfMonth, 10);
      const months = month.split(',').map((m) => parseInt(m.trim(), 10));
      return getNextOnMonths(now, months, targetDay, targetHour, targetMinute);
    }

    // 6c. Hónap-tartomány: X Y Z W-Y * (pl. 0 0 1 6-8 * = június-augusztus)
    const monthRangeMatch = month.match(/^(\d+)-(\d+)$/);
    const isMonthRange = monthRangeMatch && /^\d+$/.test(minute) && /^\d+$/.test(hour)
      && /^\d+$/.test(dayOfMonth) && dayOfWeek === '*';
    if (isMonthRange) {
      const targetMinute = parseInt(minute, 10);
      const targetHour = parseInt(hour, 10);
      const targetDay = parseInt(dayOfMonth, 10);
      const monthStart = parseInt(monthRangeMatch[1], 10);
      const monthEnd = parseInt(monthRangeMatch[2], 10);
      return getNextMonthRange({ now, monthStart, monthEnd, day: targetDay, hour: targetHour, minute: targetMinute });
    }

    // ========== SPECIÁLIS ==========

    // 7. Első vasárnap speciális szintaxis: 0 3 * * 0#1
    if (schedule === '0 3 * * 0#1' || /^\d+ \d+ \* \* \d+#1$/.test(schedule)) {
      const parts = schedule.match(/^(\d+) (\d+) \* \* (\d+)#1$/);
      if (parts) {
        const targetMinute = parseInt(parts[1], 10);
        const targetHour = parseInt(parts[2], 10);
        const targetDayOfWeek = parseInt(parts[3], 10);
        return getNextFirstWeekdayOfMonth(now, targetDayOfWeek, targetHour, targetMinute);
      }
    }

    // Fallback: következő nap
    return getNextDay(now);
  } catch (error) {
    console.error('Cron parse error:', error);
    return null;
  }
}

// ============================================
// UNIVERZÁLIS CRON IDŐPONT SZÁMÍTÓK
// ============================================

// Perces intervallumok: */X * * * *
function getNextEveryXMinutes(now, interval) {
  const next = new Date(now);
  const currentMinute = next.getMinutes();
  const currentSecond = next.getSeconds();
  const nextMinute = Math.ceil((currentMinute + (currentSecond > 0 ? 1 : 0)) / interval) * interval;

  next.setMinutes(nextMinute, 0, 0);
  if (next <= now) {
    next.setMinutes(next.getMinutes() + interval);
  }
  return next.toISOString();
}
// Konkrét perc minden órában: X * * * *
function getNextHourlyAtMinute(now, minute) {
  const next = new Date(now);
  next.setMinutes(minute, 0, 0);
  if (next <= now) {
    next.setHours(next.getHours() + 1);
  }
  return next.toISOString();
}

// Óránkénti intervallumok: X */Y * * *
function getNextEveryXHours(now, interval, minute = 0) {
  const next = new Date(now);
  const currentHour = next.getHours();
  const currentMinute = next.getMinutes();

  // Dinamikus intervallum slotok generálása (pl. interval=6 -> [0, 6, 12, 18])
  const slots = [];
  for (let h = 0; h < 24; h += interval) {
    slots.push(h);
  }

  // Keressük a következő slotot
  let nextSlot = slots.find((slot) => {
    if (slot > currentHour) {return true;}
    return slot === currentHour && currentMinute < minute;
  });

  // Ha nincs több slot ma, akkor holnap az első slot
  if (!nextSlot && nextSlot !== 0) {
    next.setDate(next.getDate() + 1);
    nextSlot = slots[0];
  }

  next.setHours(nextSlot, minute, 0, 0);
  return next.toISOString();
}

// Napi időpont: X Y * * *
function getNextDailyAtTime(now, hour, minute = 0) {
  const next = new Date(now);
  next.setHours(hour, minute, 0, 0);
  if (next <= now) {
    next.setDate(next.getDate() + 1);
  }
  return next.toISOString();
}

// Havi konkrét nap: X Y Z * *
function getNextMonthlyAtDayAndTime(now, day, hour, minute) {
  const next = new Date(now);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);

  // Ha a dátum már elmúlt ebben a hónapban, menjünk a következő hónapra
  if (next <= now) {
    next.setMonth(next.getMonth() + 1);
    next.setDate(day);
  }

  return next.toISOString();
}

// Nap-tartomány: X Y A-B * * (pl. 0 5 1-7 * *)
function getNextDayRangeAtTime(now, rangeStart, rangeEnd, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDate();

  // Keressük a következő napot a tartományban
  for (let day = currentDay; day <= rangeEnd; day++) {
    next.setDate(day);
    next.setHours(hour, minute, 0, 0);

    if (next > now && day >= rangeStart && day <= rangeEnd) {
      return next.toISOString();
    }
  }

  // Ha ebben a hónapban már nincs, akkor következő hónap első napja a tartományból
  next.setMonth(next.getMonth() + 1);
  next.setDate(rangeStart);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Heti konkrét nap: X Y * * Z
function getNextWeeklyAtDayAndTime(now, dayOfWeek, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDay();

  // Számoljuk ki, hány nap múlva van a cél nap
  let daysUntil = dayOfWeek - currentDay;
  if (daysUntil < 0) {
    daysUntil += 7;
  } else if (daysUntil === 0) {
    // Ma van a cél nap - nézzük meg az időt
    next.setHours(hour, minute, 0, 0);
    if (next <= now) {
      daysUntil = 7; // Következő héten
    }
  }

  next.setDate(next.getDate() + daysUntil);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Éves konkrét dátum: X Y Z W *
function getNextYearlyAtDate(now, month, day, hour, minute) {
  const next = new Date(now);
  next.setMonth(month - 1); // JavaScript hónapok 0-indexeltek
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);

  // Ha már elmúlt idén, akkor jövőre
  if (next <= now) {
    next.setFullYear(next.getFullYear() + 1);
  }

  return next.toISOString();
}

function getNextDay(now) {
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  return tomorrow.toISOString();
}

// ============================================
// KIEGÉSZÍTŐ SEGÉDFÜGGVÉNYEK (új minták)
// ============================================

// Perc-tartomány: X-Y * * * *
function getNextMinuteRangeInHour(now, rangeStart, rangeEnd) {
  const next = new Date(now);
  const currentMinute = next.getMinutes();

  // Keressük a következő percet a tartományban
  for (let min = currentMinute + 1; min <= rangeEnd; min++) {
    if (min >= rangeStart) {
      next.setMinutes(min, 0, 0);
      return next.toISOString();
    }
  }

  // Következő óra első perce a tartományból
  next.setHours(next.getHours() + 1);
  next.setMinutes(rangeStart, 0, 0);
  return next.toISOString();
}

// Több konkrét perc: X,Y,Z * * * *
function getNextAtMinutes(now, minutes) {
  const next = new Date(now);
  const currentMinute = next.getMinutes();

  const sortedMinutes = minutes.sort((a, b) => a - b);
  const nextMinute = sortedMinutes.find((m) => m > currentMinute);

  if (nextMinute === undefined) {
    next.setHours(next.getHours() + 1);
    next.setMinutes(sortedMinutes[0], 0, 0);
  } else {
    next.setMinutes(nextMinute, 0, 0);
  }

  return next.toISOString();
}

// Óra-tartomány: X Y-Z * * *
function getNextHourRangeAtMinute(now, rangeStart, rangeEnd, minute) {
  const next = new Date(now);
  const currentHour = next.getHours();

  // Keressük a következő órát a tartományban
  for (let hour = currentHour; hour <= rangeEnd; hour++) {
    if (hour >= rangeStart) {
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő nap első órája a tartományból
  next.setDate(next.getDate() + 1);
  next.setHours(rangeStart, minute, 0, 0);
  return next.toISOString();
}

// Több konkrét óra: X Y,Z * * *
function getNextAtHours(now, hours, minute) {
  const next = new Date(now);
  const currentHour = next.getHours();
  const currentMinute = next.getMinutes();

  const sortedHours = hours.sort((a, b) => a - b);
  const nextHour = sortedHours.find((h) => h > currentHour || (h === currentHour && minute > currentMinute));

  if (nextHour === undefined) {
    next.setDate(next.getDate() + 1);
    next.setHours(sortedHours[0], minute, 0, 0);
  } else {
    next.setHours(nextHour, minute, 0, 0);
  }

  return next.toISOString();
}

// Több hétköznap: X Y * * A,B,C
function getNextOnWeekdays(now, daysOfWeek, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDay();

  const sortedDays = daysOfWeek.sort((a, b) => a - b);

  // Próbáljuk meg ma
  next.setHours(hour, minute, 0, 0);
  if (next > now && sortedDays.includes(currentDay)) {
    return next.toISOString();
  }

  // Keressük a következő napot
  for (let i = 1; i <= 7; i++) {
    const testDay = (currentDay + i) % 7;
    if (sortedDays.includes(testDay)) {
      next.setDate(next.getDate() + i);
      next.setHours(hour, minute, 0, 0);
      return next.toISOString();
    }
  }

  return next.toISOString();
}

// Hétköznap-tartomány: X Y * * A-B
function getNextWeekdayRange(now, dowStart, dowEnd, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDay();

  // Próbáljuk meg ma
  next.setHours(hour, minute, 0, 0);
  if (next > now && currentDay >= dowStart && currentDay <= dowEnd) {
    return next.toISOString();
  }

  // Keressük a következő napot a tartományban
  for (let i = 1; i <= 7; i++) {
    const testDay = (currentDay + i) % 7;
    if (testDay >= dowStart && testDay <= dowEnd) {
      next.setDate(next.getDate() + i);
      next.setHours(hour, minute, 0, 0);
      return next.toISOString();
    }
  }

  return next.toISOString();
}

// Több konkrét nap havonta: X Y A,B,C * *
function getNextOnMonthDays(now, days, hour, minute) {
  const next = new Date(now);
  const currentDay = next.getDate();

  const sortedDays = days.sort((a, b) => a - b);

  // Próbáljuk meg ebben a hónapban
  for (const day of sortedDays) {
    if (day > currentDay || (day === currentDay && next.getHours() < hour)
        || (day === currentDay && next.getHours() === hour && next.getMinutes() < minute)) {
      next.setDate(day);
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő hónap első napja a listából
  next.setMonth(next.getMonth() + 1);
  next.setDate(sortedDays[0]);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Első adott hétköznap a hónapban: X Y 1-7 * Z vagy X Y * * Z#1
function getNextFirstWeekdayOfMonth(now, dayOfWeek, hour, minute) {
  // Aktuális hónap első adott hétköznapja
  const currentMonthFirst = new Date(now.getFullYear(), now.getMonth(), 1);
  const firstTarget = new Date(currentMonthFirst);

  while (firstTarget.getDay() !== dayOfWeek) {
    firstTarget.setDate(firstTarget.getDate() + 1);
  }
  firstTarget.setHours(hour, minute, 0, 0);

  if (now < firstTarget) {
    return firstTarget.toISOString();
  }

  // Következő hónap első adott hétköznapja
  const nextMonthFirst = new Date(now.getFullYear(), now.getMonth() + 1, 1);
  const nextFirstTarget = new Date(nextMonthFirst);

  while (nextFirstTarget.getDay() !== dayOfWeek) {
    nextFirstTarget.setDate(nextFirstTarget.getDate() + 1);
  }
  nextFirstTarget.setHours(hour, minute, 0, 0);
  return nextFirstTarget.toISOString();
}

// Hónap intervallum: X Y Z */N *
function getNextEveryXMonths(now, interval, day, hour, minute) {
  const next = new Date(now);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);

  // Ha már elmúlt ebben a hónapban
  if (next <= now) {
    next.setMonth(next.getMonth() + interval);
    next.setDate(day);
  }

  return next.toISOString();
}

// Több hónap: X Y Z W,X *
function getNextOnMonths(now, months, day, hour, minute) {
  const next = new Date(now);
  const currentMonth = next.getMonth() + 1; // 1-12

  const sortedMonths = months.sort((a, b) => a - b);

  // Próbáljuk meg idén
  for (const month of sortedMonths) {
    const isMonthPassed = month > currentMonth
        || (month === currentMonth && next.getDate() < day)
        || (month === currentMonth && next.getDate() === day && next.getHours() < hour)
        || (month === currentMonth && next.getDate() === day && next.getHours() === hour
          && next.getMinutes() < minute);
    if (isMonthPassed) {
      next.setMonth(month - 1);
      next.setDate(day);
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő évben az első hónap
  next.setFullYear(next.getFullYear() + 1);
  next.setMonth(sortedMonths[0] - 1);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// Hónap-tartomány: X Y Z W-Y *
function getNextMonthRange({ now, monthStart, monthEnd, day, hour, minute }) {
  const next = new Date(now);
  const currentMonth = next.getMonth() + 1;

  // Próbáljuk meg ebben az évben
  for (let month = currentMonth; month <= monthEnd; month++) {
    if (month >= monthStart) {
      next.setMonth(month - 1);
      next.setDate(day);
      next.setHours(hour, minute, 0, 0);
      if (next > now) {
        return next.toISOString();
      }
    }
  }

  // Következő évben az első hónap a tartományból
  next.setFullYear(next.getFullYear() + 1);
  next.setMonth(monthStart - 1);
  next.setDate(day);
  next.setHours(hour, minute, 0, 0);
  return next.toISOString();
}

// ============================================
// RÉGI FÜGGVÉNYEK (backwards compatibility - már nem használt, de meghagyva)
// ============================================

// Cron státusz lekérdezése
router.get('/status', requireAuth, async (req, res) => {
  try {
    const jobs = await CronJob.findAll();
    const cronJobs = jobs.map((job) => {
      const nextIso = getNextCronTime(job.schedule);
      let nextRun = null;
      if (nextIso) {
        const d = new Date(nextIso);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hour = String(d.getHours()).padStart(2, '0');
        const minute = String(d.getMinutes()).padStart(2, '0');
        nextRun = `${year}. ${month}. ${day}. ${hour}:${minute}`;
      }
      return {
        id: job.id,
        name: job.name,
        description: job.description,
        schedule: job.schedule,
        isActive: job.isActive,
        lastRun: null, // TODO: implement tracking
        nextRun
      };
    });
    res.json({ success: true, cronJobs });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Cron frissítése
router.post('/update', requireAuth, async (req, res) => {
  try {
    const { id, schedule, isActive } = req.body;
    if (!id || !schedule) {
      return res.status(400).json({ success: false, message: 'Hiányzó adat.' });
    }
    const job = await CronJob.findByPk(id);
    if (!job) {
      return res.status(404).json({ success: false, message: 'Feladat nem található.' });
    }
    job.schedule = schedule;
    if (typeof isActive !== 'undefined') { job.isActive = Boolean(isActive); }
    await job.save();
    res.json({ success: true, message: 'Feladat frissítve.' });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

module.exports = router;
